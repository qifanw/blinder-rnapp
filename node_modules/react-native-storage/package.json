{
  "_args": [
    [
      {
        "raw": "react-native-storage@^0.2.1",
        "scope": null,
        "escapedName": "react-native-storage",
        "name": "react-native-storage",
        "rawSpec": "^0.2.1",
        "spec": ">=0.2.1 <0.3.0",
        "type": "range"
      },
      "/Users/wqf/Desktop/mgh-rnapp"
    ]
  ],
  "_cnpm_publish_time": 1496366882519,
  "_from": "react-native-storage@^0.2.1",
  "_hasShrinkwrap": false,
  "_id": "react-native-storage@0.2.2",
  "_location": "/react-native-storage",
  "_nodeVersion": "8.0.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/react-native-storage-0.2.2.tgz_1496366882345_0.7554421653039753"
  },
  "_npmUser": {
    "name": "sunnylqm",
    "email": "sunnylqm@qq.com"
  },
  "_npmVersion": "5.0.0",
  "_phantomChildren": {},
  "_requested": {
    "raw": "react-native-storage@^0.2.1",
    "scope": null,
    "escapedName": "react-native-storage",
    "name": "react-native-storage",
    "rawSpec": "^0.2.1",
    "spec": ">=0.2.1 <0.3.0",
    "type": "range"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "http://cnpm.jinhui365.cn/react-native-storage/download/react-native-storage-0.2.2.tgz",
  "_shasum": "4449197f122b2da0650e3704e1f050260ed58d9f",
  "_shrinkwrap": null,
  "_spec": "react-native-storage@^0.2.1",
  "_where": "/Users/wqf/Desktop/mgh-rnapp",
  "author": {
    "name": "sunnylqm"
  },
  "bugs": {
    "url": "https://github.com/sunnylqm/react-native-storage/issues"
  },
  "dependencies": {},
  "description": "A local storage wrapper for both react-native(AsyncStorage) and browser(localStorage). Support size controlling, auto expiring, remote data auto syncing and getting batch data in one query.",
  "devDependencies": {
    "babel-jest": "^19.0.0",
    "babel-plugin-transform-object-rest-spread": "^6.23.0",
    "babel-preset-es2015": "^6.24.1",
    "jest": "^19.0.2"
  },
  "directories": {},
  "dist": {
    "shasum": "4449197f122b2da0650e3704e1f050260ed58d9f",
    "size": 41046,
    "noattachment": false,
    "key": "/react-native-storage/-/react-native-storage-0.2.2.tgz",
    "tarball": "http://cnpm.jinhui365.cn/react-native-storage/download/react-native-storage-0.2.2.tgz"
  },
  "gitHead": "f799fcd818bcbc4ffecb20e90495fc92d3cf4ec5",
  "homepage": "https://github.com/sunnylqm/react-native-storage#readme",
  "jest": {
    "verbose": true,
    "bail": true,
    "setupFiles": [
      "./jestSupport/mockStorage.js"
    ]
  },
  "keywords": [
    "react-native",
    "localStorage",
    "AsyncStorage"
  ],
  "license": "MIT",
  "main": "storage.js",
  "maintainers": [
    {
      "name": "sunnylqm",
      "email": "sunnylqm@qq.com"
    }
  ],
  "name": "react-native-storage",
  "optionalDependencies": {},
  "publish_time": 1496366882519,
  "readme": "# react-native-storage [![Build Status](https://travis-ci.org/sunnylqm/react-native-storage.svg)](https://travis-ci.org/sunnylqm/react-native-storage)  [![npm version](https://badge.fury.io/js/react-native-storage.svg)](http://badge.fury.io/js/react-native-storage)\n\nThis is a local storage wrapper for both react-native(AsyncStorage) and browser(localStorage). [ES6](http://babeljs.io/docs/learn-es2015/) syntax, promise for async load, fully tested with jest.\n\n查看中文文档[请点击README-CHN.md](README-CHN.md)\n\n## Install\n\n\tnpm install react-native-storage --save\n\n## Usage\n\n### Config\n#### For Web\nYou need to use [webpack](http://webpack.github.io/) and [babel](https://babeljs.io/) to enable es6 modules for web development.   \nYou should add the following lines to your webpack config:  \n\n```javascript\n  // ...\n  module: {\n    loaders: [\n      // ...\n        {\n          test: /\\.js?$/,\n          include: [\n            // path.join(__dirname, 'your-own-js-files'),\n            // path.join(__dirname, 'node_modules/some-other-lib-that-needs-babel'),\n            path.join(__dirname, 'node_modules/react-native-storage')\n          ],\n          loader: 'babel',\n          query: {\n            cacheDirectory: true,\n            presets: ['es2015', 'stage-1', 'react'],\n            plugins: ['transform-runtime']\n          }\n        }\n    ]\n  }\n\n```  \n\n#### For React Native\nYou don't have to configure anything(but require react native version >= 0.13).\n \n\n### Import\n\n```bash\nimport Storage from 'react-native-storage';\n```  \n\nDo not use `require('react-native-storage')`, which would cause error in react native version >= 0.16.\n\n### Init\n\n```js\nimport { AsyncStorage } from 'react-native';\n\nvar storage = new Storage({\n\t// maximum capacity, default 1000 \n\tsize: 1000,\n\n\t// Use AsyncStorage for RN, or window.localStorage for web.\n\t// If not set, data would be lost after reload.\n\tstorageBackend: AsyncStorage,\n\t\n\t// expire time, default 1 day(1000 * 3600 * 24 milliseconds).\n\t// can be null, which means never expire.\n\tdefaultExpires: 1000 * 3600 * 24,\n\t\n\t// cache data in the memory. default is true.\n\tenableCache: true,\n\t\n\t// if data was not found in storage or expired,\n\t// the corresponding sync method will be invoked and return \n\t// the latest data.\n\tsync : {\n\t\t// we'll talk about the details later.\n\t}\n})\t\n\n// I suggest you have one(and only one) storage instance in global scope.\n\n// for web\n// window.storage = storage;\n\n// for react native\n// global.storage = storage;\n```\n\n### Save & Load & Remove\n\n```js\n// Save something with key only. \n// Something more unique, and constantly being used.\n// They are permanently stored unless you remove.\nstorage.save({\n\tkey: 'loginState',   // Note: Do not use underscore(\"_\") in key!\n\tdata: { \n\t\tfrom: 'some other site',\n\t\tuserid: 'some userid',\n\t\ttoken: 'some token'\n\t},\n\t\n\t// if not specified, the defaultExpires will be applied instead.\n\t// if set to null, then it will never expire.\n\texpires: 1000 * 3600\n});\n\n// load\nstorage.load({\n\tkey: 'loginState',\n\t\n\t// autoSync(default true) means if data not found or expired,\n\t// then invoke the corresponding sync method\n\tautoSync: true,\n\t\n\t// syncInBackground(default true) means if data expired,\n\t// return the outdated data first while invoke the sync method.\n\t// It can be set to false to always return data provided by sync method when expired.(Of course it's slower)\n\tsyncInBackground: true,\n\t\n\t// you can pass extra params to sync method\n\t// see sync example below for example\n\tsyncParams: {\n\t  extraFetchOptions: {\n\t    // blahblah\n\t  },\n\t  someFlag: true,\n\t},\n}).then(ret => {\n\t// found data go to then()\n\tconsole.log(ret.userid);\n}).catch(err => {\n\t// any exception including data not found \n\t// goes to catch()\n\tconsole.warn(err.message);\n\tswitch (err.name) {\n\t    case 'NotFoundError':\n\t        // TODO;\n\t        break;\n        case 'ExpiredError':\n            // TODO\n            break;\n\t}\n})\n\n// --------------------------------------------------\n\n// Save something with key and id. Something of the same type(key). \n// There is a quota over \"key-id\" data(the size parameter you pass in constructor).\n// By default the 1001th data will overwrite the 1st data. \n// If you then load the 1st data, a catch(NotFoundError) or sync will be invoked.\nvar userA = {\n\tname: 'A',\n\tage: 20,\n\ttags: [\n\t\t'geek',\n\t\t'nerd',\n\t\t'otaku'\n\t]\n};\n\nstorage.save({\n\tkey: 'user',  // Note: Do not use underscore(\"_\") in key!\n\tid: '1001',\t  // Note: Do not use underscore(\"_\") in id!\t\n\tdata: userA,\n\texpires: 1000 * 60\t \n});\n\n// load\nstorage.load({\n\tkey: 'user',\n\tid: '1001'\n}).then(ret => {\n\t// found data goes to then()\n\tconsole.log(ret.userid);\n}).catch(err => {\n\t// any exception including data not found \n\t// goes to catch()\n\tconsole.warn(err.message);\n\tswitch (err.name) {\n\t    case 'NotFoundError':\n\t        // TODO;\n\t        break;\n        case 'ExpiredError':\n            // TODO\n            break;\n\t}\n});\n\n// --------------------------------------------------\n\n// getIdsForKey\nstorage.getIdsForKey('user').then(ids => {\n    console.log(ids);\n});\n\n// getAllDataForKey\nstorage.getAllDataForKey('user').then(users => {\n    console.log(users);\n});\n\n// !! clear all data under a key\nstorage.clearMapForKey('user');\n\n\n// --------------------------------------------------  \n\n// remove single record\nstorage.remove({\n\tkey: 'lastPage'\n});\nstorage.remove({\n\tkey: 'user',\n\tid: '1001'\n});\n\n// !! clear map and remove all key-id data (but keep the key-only data)\nstorage.clearMap();\n```\n\n### Sync remote data(refresh)\nYou can pass sync methods as one object parameter to the storage constructor, but also you can add it any time.\n\n```js\nstorage.sync = {\n\n\t// The name of the sync method must be the same of the data's key\n\t// And the passed params will be an all-in-one object.\n\t// You can use promise here. \n\t// Or plain callback function with resolve/reject, like:\n\tuser(params){\n\t\tlet { id, resolve, reject, syncParams: { extraFetchOptions, someFlag } } = params;\n\t\tfetch('user/', {\n\t\t\tmethod: 'GET',\n\t\t\tbody: 'id=' + id,\n\t\t    ...extraFetchOptions,\n\t\t}).then(response => {\n\t\t\treturn response.json();\n\t\t}).then(json => {\n\t\t\t// console.log(json);\n\t\t\tif(json && json.user){\n\t\t\t\tstorage.save({\n\t\t\t\t\tkey: 'user',\n\t\t\t\t\tid,\n\t\t\t\t\tdata: json.user\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (someFlag) {\n\t\t\t\t  // do something for this extra param\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Call resolve() when succeed\n\t\t\t\tresolve && resolve(json.user);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// Call reject() when failed\n\t\t\t\treject && reject(new Error('data parse error'));\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tconsole.warn(err);\n\t\t\treject && reject(err);\n\t\t});\n\t}\n}\n```\n\nWith this example sync method, when you invoke:    \n\n```js\nstorage.load({\n\tkey: 'user',\n\tid: '1002'\n}).then(...)\n```\n\nIf there is no user 1002 stored currently, then storage.sync.user would be invoked to fetch remote data and returned.    \n\n### Load batch data\n\n```js\n// Load batch data with the same parameters as storage.load, but in an array.\n// It will invoke sync methods on demand, \n// and finally return them all in an ordered array.\n\nstorage.getBatchData([\n\t{ key: 'loginState' },\n\t{ key: 'checkPoint', syncInBackground: false },\n\t{ key: 'balance' },\n\t{ key: 'user', id: '1009' }\n])\n.then(results => {\n\tresults.forEach(result => {\n\t\tconsole.log(result); \n\t})\n})\n\n// Load batch data with one key and an array of ids.\nstorage.getBatchDataWithIds({\n\tkey: 'user', \n\tids: ['1001', '1002', '1003']\n})\n.then( ... )\n```\n\nThere is a notable difference between the two methods except the arguments. **getBatchData** will invoke different sync methods(since the keys may be different) one by one when corresponding data is missing. However, **getBatchDataWithIds** will collect missing data, push their ids to an array, then pass the array to the corresponding sync method(to avoid too many requests) once, so you need to implement array query on server end and handle the parameters of sync method properly(cause the id parameter can be a single string or an array of strings).\n\n\n#### You are welcome to ask any question in the [issues](https://github.com/sunnylqm/react-native-storage/issues) page.\n\n### Changelog\n\n#### 0.2.2\n1. check key availability in clearMapForKey\n\n#### 0.2.0\n1. `rawData` is now deprecated, use \"data\" instead!\n2. Upgrade jest to 19.0.0\n\n#### 0.1.5\n1. Now you can pass extra params to sync method.\n2. Fix clearMap\n\n#### 0.1.4\n1. Now you can check error type (NotFoundError and ExpiredError) in catch\n2. Optimize cache strategy\n\n#### 0.1.3\n1. Now you need to specify storageBackend(AsyncStorage or window.localStorage), otherwise the data would not be persisted.\n\n#### 0.1.2\n1. Now when load() failed to find data, it will throw an Error with message instead of undefined.\n\n#### 0.1.1\n1. `defaultExpires` can be `null` now, which means never expire.\n\n#### 0.1.0\n1. add getIdsForKey, getAllDataForKey, clearMapForKey methods\n2. fix some expires logic\n3. refactor unit tests\n\n#### 0.0.16\n1. getBatchDataWithIds now won't invoke sync if everything is ready in storage.\n\n#### 0.0.15\n1. Fix bugs in promise chain.\n2. Can be used without any storage backend.(Use in-memory map)\n\n#### 0.0.10  \n1. All methods except remove and clearMap are now totally promisified. Even custom sync methods can be promise. So you can chain them now. \n2. Adjust map structure.\n3. Improved some test cases.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/sunnylqm/react-native-storage.git"
  },
  "scripts": {
    "test": "jest"
  },
  "version": "0.2.2"
}
